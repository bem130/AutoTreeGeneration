<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <canvas id="out"></canvas>
</body>
</html>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({canvas: document.getElementById('out')});
renderer.setSize(window.innerWidth, window.innerHeight);


// var axes = new THREE.AxesHelper(10);
// scene.add(axes);

camera.position.z = 10;
camera.position.y = 5;

function createCylinder(pointA, pointB, radius, color) {  // generated by claude
    const center = new THREE.Vector3().addVectors(pointA, pointB).multiplyScalar(0.5);
    const length = pointA.distanceTo(pointB);
    const geometry = new THREE.CylinderGeometry(radius, radius, length, 32);
    const material = new THREE.MeshBasicMaterial({color: color});
    const cylinder = new THREE.Mesh(geometry, material);
    cylinder.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 1, 0),
        new THREE.Vector3().subVectors(pointB, pointA).normalize()
    );
    cylinder.position.copy(center);
    return cylinder;
}
function animate() {
    requestAnimationFrame(animate);
    // シーンを少し回転させる
    scene.rotation.y += 0.05;
    renderer.render(scene, camera);
}

animate();

// ウィンドウリサイズ対応
window.addEventListener('resize', onWindowResize, false);

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function drawBranch(pointA,pointB,radius,color) {
    const cylinderMesh = createCylinder(new THREE.Vector3(...pointA),new THREE.Vector3(...pointB),radius,color);
    scene.add(cylinderMesh);
}
</script>
<script>

function lengthN(param,n,i) {
    return param.RootLen*(param.Ps**(n-1))*(param.Psi**(i-1));
}
function radiusN(param,n,i) {
    return param.RootRad*(param.Prs**(n-1))*(param.Prsi**(i-1));
}
function newAngle(param,n,i) {
    return (Math.random()-0.5)*param.RootAngle*(param.Pa**(n-1))*(param.Pai**(i-1));
}

function mulMatVec(mat,vec) {
    const res = [0, 0, 0];
    for (let i=0;i<3;i++) {
        for (let j=0;j<3;j++) {
            res[i] += mat[i][j]*vec[j];
        }
    }
    return res;
}
function mulMat(matrixA, matrixB) {
    const res = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ];
    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
            for (let k = 0; k < 3; k++) {
                res[i][j] += matrixA[i][k] * matrixB[k][j];
            }
        }
    }
    return res;
}
function RotMat(x,y,z) {
    const X = [
        [1,0,0],
        [0,Math.cos(x),Math.sin(x)],
        [0,-Math.sin(x),Math.cos(x)],
    ];
    const Y = [
        [Math.cos(y),0,-Math.sin(y)],
        [0,1,0],
        [Math.sin(y),0,Math.cos(y)],
    ];
    const Z = [
        [Math.cos(z),Math.sin(y),0],
        [-Math.sin(z),Math.cos(z),0],
        [0,0,1],
    ];
    return mulMat(mulMat(X,Y),Z);
}

function rnd(min,max) {
    return Math.random()*(max-min)+min;
}

function rotateVec(vec,rx,ry,rz) {
    return mulMatVec(RotMat(rx,ry,rz),vec);
}
function scaleVec(vec,scale) {
    return [vec[0]*scale,vec[1]*scale,vec[2]*scale];
}
function addVec(a,b) {
    return [a[0]+b[0],a[1]+b[1],a[2]+b[2]];
}

start();
function start() {
    for (let i=0;i<1;i++) {
        const param = {
            RootLen: rnd(1,2), // 長さの基準
            RootRad: rnd(0.02,0.05), // 太さの基準
            RootAngle: rnd(0.5,1), // 傾きの基準
            Ps: rnd(0.6,0.65), // 長さの比 世代間
            Psi: rnd(0.4,0.7), // 長さの比 兄弟間
            Prs: rnd(0.6,0.7), // 太さの比 世代間
            Prsi: rnd(0.6,0.7), // 太さの比 兄弟間
            Pa: rnd(1.1,1.4), // 角度の比 世代間
            Pai: rnd(1.2,2), // 角度の比 兄弟間
            branchNum: [1,rnd(1,2)], // 枝分かれのしやすさ
            branchColor: [[rnd(0,15),rnd(15,30)],[rnd(20,30),rnd(30,50)],[rnd(10,20),rnd(20,45)]], // 枝の色
            leafColor: [[rnd(60,95),rnd(100,120)],[rnd(15,30),rnd(30,45)],[rnd(0,15),rnd(30,55)]], // 葉の色
        }
        newBranch(param,11,1,[0,1,0],[0,0,0]);
    }
}
function newBranch(param,max,n,vec,startPos,I=1) {
    for (let i=0;i<I;i++) {
        const nangle = rotateVec(vec,newAngle(param,n,i),newAngle(param,n,i),newAngle(param,n,i));
        const npos = addVec(startPos,scaleVec(nangle,lengthN(param,n,i)));
        if (n<max) {
            newBranch(param,max,n+1,nangle,npos,Math.random()*param.branchNum[1]+param.branchNum[0]);
        }
        let color;
        let radius;
        if (n<8) {
            color = `hsl(${Math.floor(rnd(...param.branchColor[0]))},${Math.floor(rnd(...param.branchColor[1]))}%,${Math.floor(rnd(...param.branchColor[2]))}%)`;
            radius = radiusN(param,n,i);
        }
        else {
            color = `hsl(${Math.floor(rnd(...param.leafColor[0]))},${Math.floor(rnd(...param.leafColor[1]))}%,${Math.floor(rnd(...param.leafColor[2]))}%)`;
            radius = radiusN(param,n,i)*2;
        }
        drawBranch(startPos,npos,radius,color)
    }
}

</script>
<style>
    body { margin: 0; }
    canvas { display: block; }
</style>